# Домашнее задание №3
В домашнем задании нужно реализовать COW (Copy-On-Write) буффер.

Идея подхода copy-on-write заключается в том, что при чтении данных используется общая копия данных буффера, но в случае изменения данных — создается новая копия данных буффера. Для реализации такого подхода можно использовать разделяемый счетчик ссылок - если при изменении данных буффера кто-то еще ссылается на этот буффер, то нужно будет сначала произвести копию данных буффера, изменить счетчик ссылок и только затем произвести изменение (если никто не ссылается на буффер, то копировать данные буффера не нужно при изменении данных).

Дополнительно еще нужно реализовать метод конвертации данных буффера в строку без копирования и дополнительного выделения памяти.



API для COW буффера будет выглядеть следующим образом:
```go
// Предположим, что все будут производить копирование
// буффера только с использованием метода Clone()
type COWBuffer struct { ... }

func NewCOWBuffer(data []byte)                         // создать буффер с определенными данными
func (b *COWBuffer) Clone() COWBuffer                  // создать новую копию буфера
func (b *COWBuffer) Close()                            // перестать использовать копию буффера
func (b *COWBuffer) Update(index int, value byte) bool // изменить определенный байт в буффере
func (b *COWBuffer) String() string                    // сконвертировать буффер в строку
```
Для выполнения домашнего задания подготовлен шаблон кодаи основные тесты, которую помогут проверить корректность реализации конвертации. Шаблона доступен по [ссылке](https://github.com/Balun-courses/deep_go/blob/master/homework/strings/homework_test.go).

Задание со звездочкой

Выполнять необязательно, но если вы уже знакомы c финализатора в Go, то попробуйте реализовать дополнительный вызов метода Close() - на случай того, если вдруг какой-то программист забудет его вызвать явно в коде (в такой реализаци множественный вызов Close() должен отрабатывать корректно).